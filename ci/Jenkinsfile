pipeline {
  agent any

  options {
    timestamps()
    timeout(time: 60, unit: 'MINUTES')
  }

  environment {
    IMAGE_NAME    = 'myapp'
    DOCKERFILE    = 'DemoApp.Dockerfile'

    TRIVY_VERSION            = '0.52.2'
    TRIVY_CACHE_DIR          = "${env.WORKSPACE}/.trivy-cache"
    TRIVY_TIMEOUT            = '40m'
    TRIVY_DB_REPOSITORY      = 'public.ecr.aws/aquasecurity/trivy-db:2'
    TRIVY_JAVA_DB_REPOSITORY = 'public.ecr.aws/aquasecurity/trivy-java-db:1'

    // Jenkins credentials IDs (existing in your screenshot)
    GMAIL_USER         = credentials('GMAIL_USER')
    GMAIL_APP_PASSWORD = credentials('GMAIL_APP_PASSWORD')
    EMAIL_TO           = credentials('EMAIL_TO')
    EMAIL_FROM_NAME    = credentials('EMAIL_FROM_NAME')
    SLACK_WEBHOOK      = credentials('SLACK_WEBHOOK')
  }

  stages {

    stage('Docker availability') {
      steps {
        sh """
          bash -lc '
            set -Eeuo pipefail
            command -v docker
            docker version
            echo "✅ Docker reachable"
          '
        """
      }
    }

    stage('Resolve repo info') {
      steps {
        script {
          env.REPO_URL = sh(script: "git -C '${env.WORKSPACE}' config --get remote.origin.url", returnStdout: true).trim()
          env.REPO_SHA = sh(script: "git -C '${env.WORKSPACE}' rev-parse HEAD", returnStdout: true).trim()
          echo "Using REPO_URL=${env.REPO_URL}"
          echo "Using REPO_SHA=${env.REPO_SHA}"
        }
      }
    }

    stage('Build image from workspace') {
      steps {
        sh """
          bash -lc '
            set -Eeuo pipefail
            echo "Building ${env.IMAGE_NAME}:${env.BUILD_NUMBER} from ${env.WORKSPACE}"
            DOCKER_BUILDKIT=1 docker build --pull \
              -f "${env.DOCKERFILE}" \
              -t "${env.IMAGE_NAME}:${env.BUILD_NUMBER}" \
              "${env.WORKSPACE}"

            docker images --format "table {{.Repository}}\\t{{.Tag}}\\t{{.ID}}\\t{{.CreatedSince}}\\t{{.Size}}" \
              | grep -E "^${env.IMAGE_NAME}[[:space:]]+${env.BUILD_NUMBER}\\\\b"
          '
        """
      }
    }

    stage('Warm Trivy DB cache (optional)') {
      when { expression { false } } // flip to true to enable
      steps {
        sh """
          bash -lc "
            set -Eeuo pipefail
            mkdir -p '${env.TRIVY_CACHE_DIR}'
            docker run --rm -e TRIVY_CACHE_DIR=/tmp/trivy-cache \
              -v '${env.TRIVY_CACHE_DIR}:/tmp/trivy-cache' \
              aquasec/trivy:${env.TRIVY_VERSION} \
              --download-db-only --no-progress || true
          "
        """
      }
    }

    stage('Scan & Generate Report') {
      steps {
        sh """
          bash -lc "
            set -Eeuo pipefail

            docker run --rm \
              -e IMAGE_NAME='${env.IMAGE_NAME}' \
              -e BUILD_NUMBER='${env.BUILD_NUMBER}' \
              -e TRIVY_CACHE_DIR='/tmp/trivy-cache' \
              -e TRIVY_TIMEOUT='${env.TRIVY_TIMEOUT}' \
              -e TRIVY_DB_REPOSITORY='${env.TRIVY_DB_REPOSITORY}' \
              -e TRIVY_JAVA_DB_REPOSITORY='${env.TRIVY_JAVA_DB_REPOSITORY}' \
              -v /var/run/docker.sock:/var/run/docker.sock \
              -v '${env.WORKSPACE}:/app' -w /app \
              python:3.11-slim bash -lc \"
                set -Eeuo pipefail
                apt-get update -qq
                apt-get install -y -qq curl ca-certificates docker.io >/dev/null

                TRIVY_VER='${env.TRIVY_VERSION}'
                curl -fsSL -o /tmp/trivy.tgz \\\\
                  'https://github.com/aquasecurity/trivy/releases/download/v'\\\$TRIVY_VER'/trivy_'\\\$TRIVY_VER'_Linux-64bit.tar.gz'
                tar -C /usr/local/bin -xzf /tmp/trivy.tgz trivy
                trivy -v

                python -V
                if [ -f requirements.txt ]; then
                  pip install --no-cache-dir -r requirements.txt
                else
                  echo 'requirements.txt not found — skipping pip install'
                fi

                mkdir -p reports
                trivy --download-db-only --no-progress || trivy --reset --download-db-only --no-progress

                python -m scanner.scan   '${env.IMAGE_NAME}:${env.BUILD_NUMBER}' 'reports/${env.IMAGE_NAME}.json'
                python -m scanner.report 'reports/${env.IMAGE_NAME}.filtered.json' 'reports/${env.IMAGE_NAME}.html'

                tar -czf /reports.tgz -C /app reports
              \"
          "
        """
      }
    }
  }

  post {
    always {
      archiveArtifacts artifacts: 'reports/**, reports.tgz', allowEmptyArchive: true

      // send email without using any Python triple-quotes
      sh """
        bash -lc "
          set -Eeuo pipefail

          # Write mailer to a temp file (literal heredoc to avoid shell expansion)
          cat > /tmp/send_email.py <<'PY'
import os, smtplib, ssl, mimetypes, email.utils
from email.message import EmailMessage

user = os.environ['GMAIL_USER']
pwd  = os.environ['GMAIL_APP_PASSWORD']
to   = os.environ['EMAIL_TO']
from_name = os.environ.get('EMAIL_FROM_NAME','Vuln Scanner')

subject = '[VulnScan] {job} build #{num} {res}'.format(
    job=os.environ.get('JOB_NAME','job'),
    num=os.environ.get('BUILD_NUM',''),
    res=os.environ.get('RESULT','')
).strip()

body = (
    'Job: {job}\\n'
    'Build: #{num}\\n'
    'URL: {url}\\n'
    'Image: {image}\\n'
    'Result: {res}\\n'
).format(
    job=os.environ.get('JOB_NAME',''),
    num=os.environ.get('BUILD_NUM',''),
    url=os.environ.get('BUILD_URL',''),
    image=os.environ.get('IMAGE_NAME',''),
    res=os.environ.get('RESULT','')
)

msg = EmailMessage()
msg['To'] = to
msg['From'] = email.utils.formataddr((from_name, user))
msg['Subject'] = subject
msg.set_content(body)

for path in [
    'reports/{image}.html'.format(image=os.environ.get('IMAGE_NAME','myapp')),
    'reports/{image}.filtered.json'.format(image=os.environ.get('IMAGE_NAME','myapp')),
    'reports/{image}.json'.format(image=os.environ.get('IMAGE_NAME','myapp'))
]:
    if os.path.exists(path):
        ctype, _ = mimetypes.guess_type(path)
        maintype, subtype = (ctype or 'application/octet-stream').split('/', 1)
        with open(path, 'rb') as f:
            msg.add_attachment(f.read(), maintype=maintype, subtype=subtype, filename=os.path.basename(path))

ctx = ssl.create_default_context()
with smtplib.SMTP_SSL(os.environ.get('SMTP_HOST','smtp.gmail.com'), int(os.environ.get('SMTP_PORT','465')), context=ctx) as s:
    s.login(user, pwd)
    s.send_message(msg)
print('Email sent to', to)
PY

          RESULT='${"${currentBuild.currentResult}"}'
          docker run --rm \
            -e GMAIL_USER='${env.GMAIL_USER}' \
            -e GMAIL_APP_PASSWORD='${env.GMAIL_APP_PASSWORD}' \
            -e EMAIL_TO='${env.EMAIL_TO}' \
            -e EMAIL_FROM_NAME='${env.EMAIL_FROM_NAME}' \
            -e SMTP_HOST='smtp.gmail.com' \
            -e SMTP_PORT='465' \
            -e RESULT='\$RESULT' \
            -e JOB_NAME='${env.JOB_NAME}' \
            -e BUILD_NUM='${env.BUILD_NUMBER}' \
            -e BUILD_URL='${env.BUILD_URL}' \
            -e IMAGE_NAME='${env.IMAGE_NAME}' \
            -v '${env.WORKSPACE}:/work' -v /tmp/send_email.py:/send_email.py \
            -w /work python:3.11-slim python /send_email.py || true
        "
      """
    }
  }
}
