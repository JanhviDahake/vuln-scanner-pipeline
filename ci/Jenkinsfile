pipeline {
  agent any

  options {
    timestamps()
    timeout(time: 1, unit: 'HOURS')
  }

  environment {
    IMAGE_NAME = 'myapp'
    DOCKER_BUILDKIT = '1'
  }

  stages {

    stage('Docker availability') {
      steps {
        sh '''
          set -e
          command -v docker
          docker version
          echo "âœ… Docker reachable"
        '''
      }
    }

    stage('Resolve repo info') {
      steps {
        script {
          sh """
            REPO_URL=\$(git -C "${WORKSPACE}" config --get remote.origin.url)
            REPO_SHA=\$(git -C "${WORKSPACE}" rev-parse HEAD)
            echo "Using REPO_URL=${REPO_URL}"
            echo "Using REPO_SHA=${REPO_SHA}"
          """
        }
      }
    }

    stage('Build image from workspace') {
      steps {
        sh '''
          set -e
          echo "Building ${IMAGE_NAME}:${BUILD_NUMBER} from workspace at ${WORKSPACE}"
          docker build --pull -f DemoApp.Dockerfile -t ${IMAGE_NAME}:${BUILD_NUMBER} .
          docker images --format 'table {{.Repository}}\t{{.Tag}}\t{{.ID}}\t{{.CreatedSince}}\t{{.Size}}' | grep -E "^${IMAGE_NAME}[[:space:]]+${BUILD_NUMBER}\\b"
        '''
      }
    }

    stage('Warm Trivy DB cache (optional)') {
      when { expression { return false } } // flip to true if you want a pre-warm
      steps {
        sh '''
          set -e
          docker run --rm aquasec/trivy:0.52.2 --download-db-only --no-progress || \
          docker run --rm aquasec/trivy:0.52.2 --reset --download-db-only --no-progress
        '''
      }
    }

    stage('Scan & Generate Report') {
      steps {
        sh '''
          set -euo pipefail
          # Run a lightweight Python container, mount workspace & docker.sock, install only what we need
          docker run --rm \
            -e IMAGE_NAME="${IMAGE_NAME}" \
            -e BUILD_NUMBER="${BUILD_NUMBER}" \
            -e TRIVY_CACHE_DIR="/tmp/trivy-cache" \
            -e TRIVY_TIMEOUT="40m" \
            -e TRIVY_DB_REPOSITORY="public.ecr.aws/aquasecurity/trivy-db:2" \
            -e TRIVY_JAVA_DB_REPOSITORY="public.ecr.aws/aquasecurity/trivy-java-db:1" \
            -v /var/run/docker.sock:/var/run/docker.sock \
            -v "${WORKSPACE}":/app \
            -w /app \
            python:3.11-slim bash -lc '
              set -euo pipefail

              apt-get update -qq
              apt-get install -y -qq curl ca-certificates >/dev/null

              # Install Trivy (static binary)
              TRIVY_VER=0.52.2
              curl -fsSL -o /tmp/trivy.tgz "https://github.com/aquasecurity/trivy/releases/download/v${TRIVY_VER}/trivy_${TRIVY_VER}_Linux-64bit.tar.gz"
              tar -C /usr/local/bin -xzf /tmp/trivy.tgz trivy
              trivy -v

              python -V

              # Install Python deps for your local scanner code
              if [ -f /app/requirements.txt ]; then
                pip install --no-cache-dir -r /app/requirements.txt
              else
                echo "requirements.txt not found at /app/requirements.txt"
                echo "Add one to the repo root (e.g., jinja2, requests, PyYAML, etc.)"
                exit 1
              fi

              mkdir -p /app/reports

              # Make sure Python can import the local scanner package
              export PYTHONPATH=/app

              # Pre-download Trivy DB (faster, more reliable)
              trivy --download-db-only --no-progress || trivy --reset --download-db-only --no-progress

              # Run the scanner (expected to produce filtered JSON + HTML)
              python -m scanner.scan   "${IMAGE_NAME}:${BUILD_NUMBER}" "/app/reports/${IMAGE_NAME}.json"
              python -m scanner.report "/app/reports/${IMAGE_NAME}.filtered.json" "/app/reports/${IMAGE_NAME}.html"
            '
        '''
      }
    }
  }

  post {
    always {
      // Archive reports even if the build fails
      archiveArtifacts artifacts: 'reports/**', fingerprint: true, onlyIfSuccessful: false

      // Send email with artifacts attached, using Jenkins credentials (no secrets in logs)
      script {
        def buildResult = currentBuild.currentResult ?: 'UNKNOWN'
        withEnv(["RESULT=${buildResult}"]) {
          withCredentials([
            string(credentialsId: 'GMAIL_USER',          variable: 'GMAIL_USER'),
            string(credentialsId: 'GMAIL_APP_PASSWORD', variable: 'GMAIL_APP_PASSWORD'),
            string(credentialsId: 'EMAIL_TO',           variable: 'EMAIL_TO'),
            string(credentialsId: 'EMAIL_FROM_NAME',    variable: 'EMAIL_FROM_NAME')
          ]) {
            sh '''
              set -euo pipefail
              SUBJECT_PREFIX="[VulnScan]"
              SMTP_HOST="smtp.gmail.com"
              SMTP_PORT="465"

              docker run --rm \
                -e GMAIL_USER \
                -e GMAIL_APP_PASSWORD \
                -e EMAIL_TO \
                -e EMAIL_FROM_NAME \
                -e SUBJECT_PREFIX \
                -e SMTP_HOST \
                -e SMTP_PORT \
                -e RESULT \
                -e JOB_NAME="${JOB_NAME}" \
                -e BUILD_NUM="${BUILD_NUMBER}" \
                -e BUILD_URL="${BUILD_URL}" \
                -e IMAGE_NAME="${IMAGE_NAME}" \
                -v "${WORKSPACE}":/out \
                python:3.11-slim sh -lc 'python - <<\\PY
import os, smtplib, ssl, mimetypes
from email.message import EmailMessage

def read_file(path):
    try:
        with open(path, "rb") as f:
            return f.read()
    except FileNotFoundError:
        return None

user = os.environ.get("GMAIL_USER")
app_pw = os.environ.get("GMAIL_APP_PASSWORD")
to = os.environ.get("EMAIL_TO")
from_name = os.environ.get("EMAIL_FROM_NAME", "Vuln Scanner")
sub_prefix = os.environ.get("SUBJECT_PREFIX", "[VulnScan]")
smtp_host = os.environ.get("SMTP_HOST", "smtp.gmail.com")
smtp_port = int(os.environ.get("SMTP_PORT", "465"))

result = os.environ.get("RESULT", "UNKNOWN")
job = os.environ.get("JOB_NAME", "job")
build = os.environ.get("BUILD_NUM", "0")
url = os.environ.get("BUILD_URL", "")
image = os.environ.get("IMAGE_NAME", "image")

outdir = "/out/reports"
html_path = f"{outdir}/{image}.html"
json_path = f"{outdir}/{image}.filtered.json"

msg = EmailMessage()
sender = f"{from_name} <{user}>"
msg["From"] = sender
msg["To"] = to
msg["Subject"] = f"{sub_prefix} {job} build #{build} {result}"
msg.set_content("See HTML version for details.")
msg.add_alternative(f"""
<p><b>Job:</b> {job}<br/>
<b>Build:</b> #{build}<br/>
<b>Result:</b> {result}<br/>
<b>Image:</b> {image}<br/>
<b>URL:</b> <a href="{url}">{url}</a></p>
<p>Artifacts are attached when available.</p>
""", subtype="html")

for path in (html_path, json_path):
    data = read_file(path)
    if not data:
        continue
    ctype, _ = mimetypes.guess_type(path)
    if ctype is None:
        ctype = "application/octet-stream"
    maintype, subtype = ctype.split("/", 1)
    msg.add_attachment(data, maintype=maintype, subtype=subtype, filename=os.path.basename(path))

context = ssl.create_default_context()
with smtplib.SMTP_SSL(smtp_host, smtp_port, context=context) as server:
    server.login(user, app_pw)
    server.send_message(msg)
print("Email sent to", to)
PY'
            '''
          }
        }
      }
    }
  }
}
