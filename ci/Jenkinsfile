pipeline {
  agent any

  options {
    timestamps()
    timeout(time: 60, unit: 'MINUTES')
  }

  environment {
    // App / image
    IMAGE_NAME    = 'myapp'
    DOCKERFILE    = 'DemoApp.Dockerfile'

    // Trivy config
    TRIVY_VERSION       = '0.52.2'
    TRIVY_CACHE_DIR     = "${env.WORKSPACE}/.trivy-cache"
    TRIVY_TIMEOUT       = '40m'
    TRIVY_DB_REPOSITORY = 'public.ecr.aws/aquasecurity/trivy-db:2'
    TRIVY_JAVA_DB_REPOSITORY = 'public.ecr.aws/aquasecurity/trivy-java-db:1'

    // Email creds (string credentials ids in Jenkins)
    GMAIL_USER         = credentials('GMAIL_USER')
    GMAIL_APP_PASSWORD = credentials('GMAIL_APP_PASSWORD')
    EMAIL_TO           = credentials('EMAIL_TO')
    EMAIL_FROM_NAME    = credentials('EMAIL_FROM_NAME')

    // Optional (not used below but kept)
    SLACK_WEBHOOK      = credentials('SLACK_WEBHOOK')
  }

  stages {

    stage('Docker availability') {
      steps {
        sh """
          bash -lc '
            set -Eeuo pipefail
            command -v docker
            docker version
            echo "✅ Docker reachable"
          '
        """
      }
    }

    stage('Resolve repo info') {
      steps {
        script {
          env.REPO_URL = sh(script: "git -C '${env.WORKSPACE}' config --get remote.origin.url", returnStdout: true).trim()
          env.REPO_SHA = sh(script: "git -C '${env.WORKSPACE}' rev-parse HEAD", returnStdout: true).trim()
          echo "Using REPO_URL=${env.REPO_URL}"
          echo "Using REPO_SHA=${env.REPO_SHA}"
        }
      }
    }

    stage('Build image from workspace') {
      steps {
        sh """
          bash -lc '
            set -Eeuo pipefail
            echo "Building ${env.IMAGE_NAME}:${env.BUILD_NUMBER} from workspace at ${env.WORKSPACE}"
            DOCKER_BUILDKIT=1 docker build --pull \
              -f "${env.DOCKERFILE}" \
              -t "${env.IMAGE_NAME}:${env.BUILD_NUMBER}" \
              "${env.WORKSPACE}"

            docker images --format "table {{.Repository}}\\t{{.Tag}}\\t{{.ID}}\\t{{.CreatedSince}}\\t{{.Size}}" \
              | grep -E "^${env.IMAGE_NAME}[[:space:]]+${env.BUILD_NUMBER}\\\\b"
          '
        """
      }
    }

    stage('Warm Trivy DB cache (optional)') {
      when { expression { return false } } // flip to true if you want a warm-up stage
      steps {
        sh """
          bash -lc '
            set -Eeuo pipefail
            mkdir -p "${env.TRIVY_CACHE_DIR}"
            docker run --rm -e TRIVY_CACHE_DIR=/tmp/trivy-cache \
              -v "${env.TRIVY_CACHE_DIR}:/tmp/trivy-cache" \
              aquasec/trivy:${env.TRIVY_VERSION} \
              --download-db-only --no-progress || true
          '
        """
      }
    }

    stage('Scan & Generate Report') {
      steps {
        sh """
          bash -lc '
            set -Eeuo pipefail

            # Run a disposable tools container that has Python + installs Trivy
            docker run --rm \\
              -e IMAGE_NAME="${env.IMAGE_NAME}" \\
              -e BUILD_NUMBER="${env.BUILD_NUMBER}" \\
              -e TRIVY_CACHE_DIR="/tmp/trivy-cache" \\
              -e TRIVY_TIMEOUT="${env.TRIVY_TIMEOUT}" \\
              -e TRIVY_DB_REPOSITORY="${env.TRIVY_DB_REPOSITORY}" \\
              -e TRIVY_JAVA_DB_REPOSITORY="${env.TRIVY_JAVA_DB_REPOSITORY}" \\
              -v /var/run/docker.sock:/var/run/docker.sock \\
              -v "${env.WORKSPACE}:/app" -w /app \\
              python:3.11-slim bash -lc "
                set -Eeuo pipefail

                apt-get update -qq
                apt-get install -y -qq curl ca-certificates docker.io >/dev/null
                TRIVY_VER='${env.TRIVY_VERSION}'
                curl -fsSL -o /tmp/trivy.tgz \\
                  \\"https://github.com/aquasecurity/trivy/releases/download/v\\\${TRIVY_VER}/trivy_\\\${TRIVY_VER}_Linux-64bit.tar.gz\\"
                tar -C /usr/local/bin -xzf /tmp/trivy.tgz trivy

                python -V
                if [ -f requirements.txt ]; then
                  pip install --no-cache-dir -r requirements.txt
                else
                  echo \\"requirements.txt not found — skipping pip install\\"
                fi

                mkdir -p reports
                trivy --download-db-only --no-progress || trivy --reset --download-db-only --no-progress

                # Run the scanner (writes raw+filtered JSON)
                python -m scanner.scan   \\"${env.IMAGE_NAME}:${env.BUILD_NUMBER}\\" \\"reports/${env.IMAGE_NAME}.json\\"
                python -m scanner.report \\"reports/${env.IMAGE_NAME}.filtered.json\\" \\"reports/${env.IMAGE_NAME}.html\\"

                tar -czf /reports.tgz -C /app reports
              "

            # copy out the tarball (already in workspace via bind mount)
            # nothing else to do here
          '
        """
      }
    }
  }

  post {
    always {
      // Archive whatever we produced (don’t fail if missing)
      archiveArtifacts artifacts: 'reports/**, reports.tgz', allowEmptyArchive: true

      // Email summary (kept simple; uses same vars)
      sh """
        bash -lc '
          set -Eeuo pipefail

          # Construct a tiny mailer in a throwaway Python container
          cat > /tmp/send_email.py <<PY
import os, smtplib, ssl, mimetypes, email.utils
from email.message import EmailMessage

user=os.environ["GMAIL_USER"]; pwd=os.environ["GMAIL_APP_PASSWORD"]
to=os.environ["EMAIL_TO"]; from_name=os.environ.get("EMAIL_FROM_NAME","Vuln Scanner")
subject=f"[VulnScan] {os.environ.get('JOB_NAME','job')} build #{os.environ.get('BUILD_NUM','')} {os.environ.get('RESULT','')}".strip()
body=f"""Job: {os.environ.get('JOB_NAME','')}
Build: #{os.environ.get('BUILD_NUM','')}
URL: {os.environ.get('BUILD_URL','')}
Image: {os.environ.get('IMAGE_NAME','')}
Result: {os.environ.get('RESULT','')}
"""

msg=EmailMessage()
msg["To"]=to
msg["From"]=email.utils.formataddr((from_name, user))
msg["Subject"]=subject
msg.set_content(body)

# Attach reports if present
for path in ["reports/${env.IMAGE_NAME}.html","reports/${env.IMAGE_NAME}.filtered.json","reports/${env.IMAGE_NAME}.json"]:
    if os.path.exists(path):
        ctype,enc=mimetypes.guess_type(path)
        maintype,subtype=(ctype or "application/octet-stream").split("/",1)
        with open(path,"rb") as f:
            msg.add_attachment(f.read(), maintype=maintype, subtype=subtype, filename=os.path.basename(path))

ctx=ssl.create_default_context()
with smtplib.SMTP_SSL(os.environ.get("SMTP_HOST","smtp.gmail.com"), int(os.environ.get("SMTP_PORT","465")), context=ctx) as s:
    s.login(user, pwd)
    s.send_message(msg)
print("Email sent to", to)
PY

          RESULT="\${currentBuild.currentResult}"
          docker run --rm \\
            -e GMAIL_USER='${env.GMAIL_USER}' \\
            -e GMAIL_APP_PASSWORD='${env.GMAIL_APP_PASSWORD}' \\
            -e EMAIL_TO='${env.EMAIL_TO}' \\
            -e EMAIL_FROM_NAME='${env.EMAIL_FROM_NAME}' \\
            -e SUBJECT_PREFIX='[VulnScan]' \\
            -e SMTP_HOST='smtp.gmail.com' \\
            -e SMTP_PORT='465' \\
            -e RESULT="\${RESULT}" \\
            -e JOB_NAME='${env.JOB_NAME}' \\
            -e BUILD_NUM='${env.BUILD_NUMBER}' \\
            -e BUILD_URL='${env.BUILD_URL}' \\
            -e IMAGE_NAME='${env.IMAGE_NAME}' \\
            -v '${env.WORKSPACE}:/work' -v /tmp/send_email.py:/send_email.py \\
            -w /work python:3.11-slim python /send_email.py || true
        '
      """
    }
  }
}
