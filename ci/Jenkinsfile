pipeline {
  agent any
  options { timestamps() }

  parameters {
    string(name: 'IMAGE_NAME', defaultValue: 'myapp', description: 'Docker image name to build & scan')
    string(name: 'DOCKERFILE', defaultValue: 'DemoApp.Dockerfile', description: 'Dockerfile path in repo')
    string(name: 'SEVERITY',   defaultValue: 'HIGH,CRITICAL', description: 'Fail gate on these severities')
    string(name: 'REPO_URL',   defaultValue: '', description: 'Git repo URL (blank = autodetect)')
    string(name: 'REPO_REF',   defaultValue: '', description: 'Git ref/branch (blank = autodetect)')
  }

  environment {
    PYTHONUNBUFFERED = '1'
    // Keep BuildKit on globally if you want; we override to 0 just for the build line.
    DOCKER_BUILDKIT  = '1'
    DOCKER_HOST      = 'tcp://host.docker.internal:2375'  // Docker Desktop TCP
  }

  stages {
    stage('Checkout') {
      steps { checkout scm }
    }

    stage('Sanity: Docker TCP') {
      steps { sh 'docker version' }
    }

    stage('Resolve repo (autodetect if blanks)') {
      steps {
        script {
          // If params empty, read them from the workspaceâ€™s Git config/HEAD
          if (!params.REPO_URL?.trim()) {
            env.REPO_URL = sh(returnStdout: true, script: "git -C '${env.WORKSPACE}' config --get remote.origin.url").trim()
          } else {
            env.REPO_URL = params.REPO_URL.trim()
          }
          if (!params.REPO_REF?.trim()) {
            // Try to get the short branch; fall back to 'main'
            def ref = sh(returnStdout: true, script: "git -C '${env.WORKSPACE}' rev-parse --abbrev-ref HEAD || echo main").trim()
            env.REPO_REF = ref ?: 'main'
          } else {
            env.REPO_REF = params.REPO_REF.trim()
          }
          echo "Using REPO_URL=${env.REPO_URL}, REPO_REF=${env.REPO_REF}"
        }
      }
    }

    stage('Build image from Git (no mounts)') {
      steps {
        // Classic builder (no buildx required) supports git URL contexts
        sh '''
          echo "Building ${IMAGE_NAME}:${BUILD_NUMBER} from ${REPO_URL}#${REPO_REF}"
          DOCKER_BUILDKIT=0 docker build \
            --pull \
            -f "${DOCKERFILE}" \
            -t "${IMAGE_NAME}:${BUILD_NUMBER}" \
            "${REPO_URL}#${REPO_REF}"
        '''
      }
    }

    stage('Scan & Generate Report (no mounts)') {
      steps {
        sh '''
          # clone repo inside container, run scanner, then extract reports via tar
          docker run --rm -e DOCKER_HOST python:3.11-slim bash -lc "
            set -e
            apt-get update -qq && apt-get install -y -qq git && rm -rf /var/lib/apt/lists/*
            git clone --branch '${REPO_REF}' --depth 1 '${REPO_URL}' /app
            cd /app
            pip install --no-cache-dir -r requirements.txt
            mkdir -p reports
            python scanner/scan.py '${IMAGE_NAME}:${BUILD_NUMBER}' 'reports/${IMAGE_NAME}.json'
            python scanner/report.py 'reports/${IMAGE_NAME}.filtered.json' 'reports/${IMAGE_NAME}.html'
            tar -czf /reports.tgz -C /app reports
          "
          CID=$(docker create --rm python:3.11-slim)
          docker cp $CID:/reports.tgz reports.tgz || true
          docker rm $CID >/dev/null 2>&1 || true
          mkdir -p reports && tar -xzf reports.tgz -C . || true
        '''
      }
    }

    stage('Email & Gate (no mounts)') {
      steps {
        withCredentials([
          string(credentialsId: 'GMAIL_USER',         variable: 'GMAIL_USER'),
          string(credentialsId: 'GMAIL_APP_PASSWORD', variable: 'GMAIL_APP_PASSWORD'),
          string(credentialsId: 'EMAIL_TO',           variable: 'EMAIL_TO')
        ]) {
          sh '''
            # Create a temp container, inject the reports, then run notify
            CID=$(docker create --rm \
                 -e DOCKER_HOST -e GMAIL_USER -e GMAIL_APP_PASSWORD -e EMAIL_TO \
                 python:3.11-slim bash -lc "
                   set -e
                   apt-get update -qq && apt-get install -y -qq git && rm -rf /var/lib/apt/lists/*
                   git clone --branch '${REPO_REF}' --depth 1 '${REPO_URL}' /app
                   cd /app
                   pip install --no-cache-dir -r requirements.txt
                   tar -xzf /reports.tgz -C .
                   python scanner/notify_email.py \
                     --image       '${IMAGE_NAME}:${BUILD_NUMBER}' \
                     --report-json 'reports/${IMAGE_NAME}.filtered.json' \
                     --report-html 'reports/${IMAGE_NAME}.html' \
                     --fail-on     '${SEVERITY}'
                 ")
            tar -czf - reports | docker cp - $CID:/reports.tgz
            docker start -a $CID
          '''
        }
      }
    }
  }

  post {
    always {
      archiveArtifacts artifacts: 'reports/*', onlyIfSuccessful: false
    }
  }
}
