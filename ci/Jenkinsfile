pipeline {
  agent any

  options {
    timestamps()
    timeout(time: 60, unit: 'MINUTES')
  }

  environment {
    IMAGE_NAME = 'myapp'
    DOCKERFILE = 'DemoApp.Dockerfile'

    TRIVY_VERSION            = '0.52.2'
    TRIVY_CACHE_DIR          = "${env.WORKSPACE}/.trivy-cache"
    TRIVY_TIMEOUT            = '40m'
    TRIVY_DB_REPOSITORY      = 'public.ecr.aws/aquasecurity/trivy-db:2'
    TRIVY_JAVA_DB_REPOSITORY = 'public.ecr.aws/aquasecurity/trivy-java-db:1'

    // Jenkins credentials (configured in your instance)
    GMAIL_USER         = credentials('GMAIL_USER')
    GMAIL_APP_PASSWORD = credentials('GMAIL_APP_PASSWORD')
    EMAIL_TO           = credentials('EMAIL_TO')
    EMAIL_FROM_NAME    = credentials('EMAIL_FROM_NAME')
    SLACK_WEBHOOK      = credentials('SLACK_WEBHOOK')
  }

  stages {

    stage('Docker availability') {
      steps {
        sh(script: '''bash -lc '
          set -Eeuo pipefail
          command -v docker
          docker version
          echo "✅ Docker reachable"
        ' ''')
      }
    }

    stage('Resolve repo info') {
      steps {
        script {
          env.REPO_URL = sh(script: "git -C '${env.WORKSPACE}' config --get remote.origin.url", returnStdout: true).trim()
          env.REPO_SHA = sh(script: "git -C '${env.WORKSPACE}' rev-parse HEAD", returnStdout: true).trim()
          echo "Using REPO_URL=${env.REPO_URL}"
          echo "Using REPO_SHA=${env.REPO_SHA}"
        }
      }
    }

    stage('Build image from workspace') {
      steps {
        sh(script: '''bash -lc '
          set -Eeuo pipefail
          echo "Building ${IMAGE_NAME}:${BUILD_NUMBER} from ${WORKSPACE}"

          # Use BuildKit only if buildx is available; else fallback to legacy builder.
          if docker buildx version >/dev/null 2>&1; then
            echo "Using BuildKit (buildx detected)"
            export DOCKER_BUILDKIT=1
          else
            echo "buildx not found; falling back to legacy builder"
            export DOCKER_BUILDKIT=0
          fi

          docker build --pull \
            -f "${DOCKERFILE}" \
            -t "${IMAGE_NAME}:${BUILD_NUMBER}" \
            "${WORKSPACE}"

          docker images --format "table {{.Repository}}\\t{{.Tag}}\\t{{.ID}}\\t{{.CreatedSince}}\\t{{.Size}}" \
            | grep -E "^${IMAGE_NAME}[[:space:]]+${BUILD_NUMBER}\\\\b"
        ' ''')
      }
    }

    stage('Warm Trivy DB cache (optional)') {
      when { expression { false } } // set to true if you want to pre-warm
      steps {
        sh(script: '''bash -lc "
          set -Eeuo pipefail
          mkdir -p '${TRIVY_CACHE_DIR}'
          docker run --rm -e TRIVY_CACHE_DIR=/tmp/trivy-cache \
            -v '${TRIVY_CACHE_DIR}:/tmp/trivy-cache' \
            aquasec/trivy:${TRIVY_VERSION} \
            --download-db-only --no-progress || true
        " ''')
      }
    }

    stage('Scan & Generate Report') {
      steps {
        sh(script: '''bash -lc "
          set -Eeuo pipefail

          docker run --rm \
            -e IMAGE_NAME='${IMAGE_NAME}' \
            -e BUILD_NUMBER='${BUILD_NUMBER}' \
            -e TRIVY_CACHE_DIR='/tmp/trivy-cache' \
            -e TRIVY_TIMEOUT='${TRIVY_TIMEOUT}' \
            -e TRIVY_DB_REPOSITORY='${TRIVY_DB_REPOSITORY}' \
            -e TRIVY_JAVA_DB_REPOSITORY='${TRIVY_JAVA_DB_REPOSITORY}' \
            -v /var/run/docker.sock:/var/run/docker.sock \
            -v '${WORKSPACE}:/app' -w /app \
            python:3.11-slim bash -lc \"
              set -Eeuo pipefail
              apt-get update -qq
              apt-get install -y -qq curl ca-certificates docker.io >/dev/null

              TRIVY_VER='${TRIVY_VERSION}'
              curl -fsSL -o /tmp/trivy.tgz \\\\
                'https://github.com/aquasecurity/trivy/releases/download/v'\\\$TRIVY_VER'/trivy_'\\\$TRIVY_VER'_Linux-64bit.tar.gz'
              tar -C /usr/local/bin -xzf /tmp/trivy.tgz trivy
              trivy -v

              python -V
              if [ -f requirements.txt ]; then
                pip install --no-cache-dir -r requirements.txt
              else
                echo 'requirements.txt not found — skipping pip install'
              fi

              mkdir -p reports
              trivy --download-db-only --no-progress || trivy --reset --download-db-only --no-progress

              python -m scanner.scan   '${IMAGE_NAME}:${BUILD_NUMBER}' 'reports/${IMAGE_NAME}.json'
              python -m scanner.report 'reports/${IMAGE_NAME}.filtered.json' 'reports/${IMAGE_NAME}.html'

              tar -czf /reports.tgz -C /app reports
            \"
        " ''')
      }
    }
  }

  post {
    always {
      script {
        // capture result once (so we can use it in a shell without Groovy interpolation)
        env.PIPE_RESULT = currentBuild.currentResult ?: 'UNKNOWN'
      }

      archiveArtifacts artifacts: 'reports/**, reports.tgz', allowEmptyArchive: true

      // Send email by piping the script via stdin. No bind mounts, no Groovy interpolation of secrets.
      sh(script: '''bash -lc '
        set -Eeuo pipefail

        docker run --rm -i \
          --env GMAIL_USER \
          --env GMAIL_APP_PASSWORD \
          --env EMAIL_TO \
          --env EMAIL_FROM_NAME \
          --env SMTP_HOST=smtp.gmail.com \
          --env SMTP_PORT=465 \
          --env RESULT="$PIPE_RESULT" \
          --env JOB_NAME="$JOB_NAME" \
          --env BUILD_NUM="$BUILD_NUMBER" \
          --env BUILD_URL="$BUILD_URL" \
          --env IMAGE_NAME="$IMAGE_NAME" \
          python:3.11-slim python - <<'"'"'PY'"'"'
import os, smtplib, ssl, mimetypes, email.utils

from email.message import EmailMessage

user = os.environ["GMAIL_USER"]
pwd  = os.environ["GMAIL_APP_PASSWORD"]
to   = os.environ["EMAIL_TO"]
from_name = os.environ.get("EMAIL_FROM_NAME","Vuln Scanner")

subject = "[VulnScan] {job} build #{num} {res}".format(
    job=os.environ.get("JOB_NAME","job"),
    num=os.environ.get("BUILD_NUM",""),
    res=os.environ.get("RESULT","")
).strip()

body = (
    "Job: {job}\\n"
    "Build: #{num}\\n"
    "URL: {url}\\n"
    "Image: {image}\\n"
    "Result: {res}\\n"
).format(
    job=os.environ.get("JOB_NAME",""),
    num=os.environ.get("BUILD_NUM",""),
    url=os.environ.get("BUILD_URL",""),
    image=os.environ.get("IMAGE_NAME",""),
    res=os.environ.get("RESULT","")
)

msg = EmailMessage()
msg["To"] = to
msg["From"] = email.utils.formataddr((from_name, user))
msg["Subject"] = subject
msg.set_content(body)

for path in [
    "reports/{image}.html".format(image=os.environ.get("IMAGE_NAME","myapp")),
    "reports/{image}.filtered.json".format(image=os.environ.get("IMAGE_NAME","myapp")),
    "reports/{image}.json".format(image=os.environ.get("IMAGE_NAME","myapp")),
]:
    if os.path.exists(path):
        ctype, _ = mimetypes.guess_type(path)
        maintype, subtype = (ctype or "application/octet-stream").split("/", 1)
        with open(path, "rb") as f:
            msg.add_attachment(f.read(), maintype=maintype, subtype=subtype, filename=os.path.basename(path))

ctx = ssl.create_default_context()
with smtplib.SMTP_SSL(os.environ.get("SMTP_HOST","smtp.gmail.com"), int(os.environ.get("SMTP_PORT","465")), context=ctx) as s:
    s.login(user, pwd)
    s.send_message(msg)
print("Email sent to", to)
PY
      ' ''')
    }
  }
}
