// Jenkinsfile - vuln-scanner-pipeline (plugin-light, webhook Slack)

pipeline {
  agent any

  options {
    timestamps()
    // ansiColor('xterm') // <- leave commented unless the AnsiColor plugin is installed
  }

  parameters {
    string(name: 'IMAGE_NAME', defaultValue: 'myapp',              description: 'Docker image name to build & scan')
    string(name: 'DOCKERFILE', defaultValue: 'DemoApp.Dockerfile', description: 'Dockerfile path in repo')
    string(name: 'SEVERITY',   defaultValue: 'HIGH,CRITICAL',      description: 'Fail gate on these severities')
    string(name: 'REPO_URL',   defaultValue: '',                   description: 'Git repo URL (blank = autodetect)')
    string(name: 'REPO_REF',   defaultValue: '',                   description: 'Branch/ref (blank = autodetect)')
    booleanParam(name: 'WARM_TRIVY_DB', defaultValue: true,        description: 'Pre-pull Trivy DB (faster after first run)')
    booleanParam(name: 'ENABLE_SLACK',  defaultValue: true,        description: 'Notify Slack via webhook (no plugin needed)')
    string(name: 'SLACK_WEBHOOK_CREDENTIAL_ID', defaultValue: '',  description: 'Secret Text cred id holding Slack Incoming Webhook URL')
  }

  environment {
    DOCKER_HOST     = 'tcp://host.docker.internal:2375' // adjust if your daemon differs
    DOCKER_BUILDKIT = '0'                                // legacy builder so remote git build works
    LANG            = 'C.UTF-8'
  }

  stages {

    stage('Checkout') {
      steps {
        checkout scm
      }
    }

    stage('Sanity: Docker TCP') {
      steps {
        sh '''
          set -e
          echo "Using DOCKER_HOST=${DOCKER_HOST}"
          docker version >/dev/null
          echo "✅ Docker reachable"
        '''
      }
    }

    stage('Resolve repo (autodetect if blanks)') {
      steps {
        script {
          env.REPO_URL = (params.REPO_URL?.trim())
              ?: sh(script: "git -C '${env.WORKSPACE}' config --get remote.origin.url", returnStdout: true).trim()

          def ref = params.REPO_REF?.trim()
          if (!ref) {
            ref = sh(
              script: "cd '${env.WORKSPACE}'; git symbolic-ref --short -q HEAD || echo HEAD",
              returnStdout: true
            ).trim()
          }
          env.REPO_REF = ref
          echo "Using REPO_URL=${env.REPO_URL}, REPO_REF=${env.REPO_REF}"
        }
      }
    }

    stage('Build image from Git (no mounts)') {
      steps {
        sh '''
          set -e
          echo "Building ${IMAGE_NAME}:${BUILD_NUMBER} from ${REPO_URL}#${REPO_REF}"
          DOCKER_BUILDKIT=0 docker build --pull -f "${DOCKERFILE}" -t "${IMAGE_NAME}:${BUILD_NUMBER}" "${REPO_URL}#${REPO_REF}"
          docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.ID}}\t{{.CreatedSince}}\t{{.Size}}" | grep "^${IMAGE_NAME}\\s\\+${BUILD_NUMBER}\\b" || true
        '''
      }
    }

    stage('Warm Trivy DB cache (conditional)') {
      when { expression { return params.WARM_TRIVY_DB } }
      steps {
        sh '''
          set -e
          echo "Pre-pulling Trivy DB images (best effort; safe to skip on network hiccups)..."
          docker pull ghcr.io/aquasecurity/trivy-db:2      || true
          docker pull ghcr.io/aquasecurity/trivy-java-db:1 || true
        '''
      }
    }

    stage('Scan & Generate Report') {
      steps {
        sh '''
          set -e

          # Create a container that will scan + package /reports.tgz, then copy it out.
          CID=$(docker create --rm -e DOCKER_HOST python:3.11-slim bash -lc '
            set -e
            apt-get update -qq && apt-get install -y -qq git ca-certificates && rm -rf /var/lib/apt/lists/*
            git clone --branch "'"${REPO_REF}"'" --depth 1 "'"${REPO_URL}"'" /app
            cd /app
            pip install --no-cache-dir -r requirements.txt
            mkdir -p reports
            python -m scanner.scan "'"${IMAGE_NAME}:${BUILD_NUMBER}"'" "reports/'"${IMAGE_NAME}"'.json"
            python -m scanner.report "reports/'"${IMAGE_NAME}"'.filtered.json" "reports/'"${IMAGE_NAME}"'.html"
            tar -czf /reports.tgz -C /app reports
          ')

          docker start -a "$CID"
          docker cp "$CID:/reports.tgz" ./reports.tgz
          docker rm "$CID" >/dev/null 2>&1 || true

          mkdir -p reports
          tar -xzf reports.tgz
          echo "Report files:"
          ls -la reports || true
        '''
      }
    }

    stage('Email Gate (send & enforce threshold)') {
      steps {
        withCredentials([
          string(credentialsId: 'GMAIL_USER',         variable: 'GMAIL_USER'),
          string(credentialsId: 'GMAIL_APP_PASSWORD', variable: 'GMAIL_APP_PASSWORD'),
          string(credentialsId: 'EMAIL_TO',           variable: 'EMAIL_TO')
        ]) {
          sh '''
            set -e
            docker run --rm \
              -e DOCKER_HOST \
              -e GMAIL_USER -e GMAIL_APP_PASSWORD -e EMAIL_TO \
              -v "$PWD":/out:ro \
              python:3.11-slim bash -lc "
                set -e
                apt-get update -qq && apt-get install -y -qq git ca-certificates && rm -rf /var/lib/apt/lists/*
                git clone --branch '${REPO_REF}' --depth 1 '${REPO_URL}' /app
                cd /app
                pip install --no-cache-dir -r requirements.txt
                python -m scanner.notify_email \
                  --image       '${IMAGE_NAME}:${BUILD_NUMBER}' \
                  --report-json '/out/reports/${IMAGE_NAME}.filtered.json' \
                  --report-html '/out/reports/${IMAGE_NAME}.html' \
                  --fail-on     '${SEVERITY}'
              "
          '''
        }
      }
    }
  }

  post {
    always {
      archiveArtifacts artifacts: 'reports/*', allowEmptyArchive: true, onlyIfSuccessful: false
    }

    success {
      script {
        if (params.ENABLE_SLACK && params.SLACK_WEBHOOK_CREDENTIAL_ID?.trim()) {
          withCredentials([string(credentialsId: params.SLACK_WEBHOOK_CREDENTIAL_ID, variable: 'SLACK_WEBHOOK_URL')]) {
            sh '''
              set -e
              MSG=$(cat <<EOF
{
  "text": "✅ ${JOB_NAME} #${BUILD_NUMBER} succeeded\\n• Image: \`${IMAGE_NAME}:${BUILD_NUMBER}\`\\n• Repo: ${REPO_URL}\\n• Ref: ${REPO_REF}\\n• ${BUILD_URL}"
}
EOF
)
              docker run --rm -i curlimages/curl -sS -X POST -H 'Content-type: application/json' --data "$MSG" "$SLACK_WEBHOOK_URL" || true
            '''
          }
        }
      }
    }

    failure {
      script {
        if (params.ENABLE_SLACK && params.SLACK_WEBHOOK_CREDENTIAL_ID?.trim()) {
          withCredentials([string(credentialsId: params.SLACK_WEBHOOK_CREDENTIAL_ID, variable: 'SLACK_WEBHOOK_URL')]) {
            sh '''
              set -e
              MSG=$(cat <<EOF
{
  "text": "❌ ${JOB_NAME} #${BUILD_NUMBER} failed\\n• Image: \`${IMAGE_NAME}:${BUILD_NUMBER}\`\\n• ${BUILD_URL}"
}
EOF
)
              docker run --rm -i curlimages/curl -sS -X POST -H 'Content-type: application/json' --data "$MSG" "$SLACK_WEBHOOK_URL" || true
            '''
          }
        }
      }
    }
  }
}
